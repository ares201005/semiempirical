#!/usr/bin/env python
# flake8: noqa

'''
whatever
'''

import ctypes
import copy
import math
import numpy as np
import warnings
from pyscf import lib
from pyscf.lib import logger
from pyscf import gto
from pyscf import scf
from pyscf.data.elements import _symbol
from .matprint2d import *

def resonance_integral(betai, betaj, alphai, alphaj, rij):
    return 0.5*(betai+betaj)*np.sqrt(rij)*np.exp(-(alphai+alphaj)*rij**2)

def diatomic_ecp_resonance_matrix(ia, ja, zi, zj, xij, rij, params, rot_mat): 
    gss = 0.0
    gsp = gps = 0.0
    gpp = 0.0
    gpi = 0.0
    gecp = np.zeros((4,4))
    nt = zi + zj
    print(f'Atoms: {zi} {zj}')
    if zi == 1 and zj == 1: # first row - first row IGNORE FOR ECP
       #jcall = 2 
       pass
       #gss = resonance_integral(params.beta_s[zi], params.beta_s[zj], params.alpha_s[zi], params.alpha_s[zj], rij)
       #gecp[0][0] = gss
       #gecp_rotate = gecp[0][0]
       ##matrix_print_2d(gecp_rotate, 1, 'gecp_rotate')       
       #matrix_print_2d(gecp, 1, 'gecp')       
       #return np.atleast_1d(gecp_rotate)
    elif (zi > 1 and zj == 1): # second row - first
       #jcall = 3
       # Only s(ecp)-s will be non-zero
       if nt == 9 or nt == 8:
          gssma = resonance_integral(params.beta_sh[zi], params.beta_ecp[zj], params.alpha_sh[zi], params.alpha_ecp[zj], rij)
          #gpsma = resonance_integral(params.beta_ph[zi], params.beta_ecp[zj], params.alpha_ph[zi], params.alpha_ecp[zj], rij)

          gssam = resonance_integral(params.beta_sh[zj], params.beta_ecp[zi], params.alpha_sh[zj], params.alpha_ecp[zi], rij)
          #gpsam = resonance_integral(params.beta_ph[zj], params.beta_ecp[zi], params.alpha_ph[zj], params.alpha_ecp[zi], rij)
       else:
          gssma = resonance_integral(params.beta_s[zi], params.beta_ecp[zj], params.alpha_s[zi], params.alpha_ecp[zj], rij)
          #gpsma = resonance_integral(params.beta_p[zi], params.beta_ecp[zj], params.alpha_p[zi], params.alpha_ecp[zj], rij)

          gssam = resonance_integral(params.beta_s[zj], params.beta_ecp[zi], params.alpha_s[zj], params.alpha_ecp[zi], rij)
          #gpsam = resonance_integral(params.beta_p[zj], params.beta_ecp[zi], params.alpha_p[zj], params.alpha_ecp[zi], rij)
       #gecp[0][0] = gss
       #gecp[0][1] = gsp
       #gecp[1][0] = -1.0*gps
       print(f'gssma: {gssma}')
       print(f'gssam: {gssam}')
       print(f'gpsma: {-gpsma}')
       print(f'gpsam: {-gpsam}')
       #print(f'gspam: {gspam}')
       gecp_rotate = np.einsum('ji,kj,km->im', rot_mat, gecp, rot_mat) 
       #gecp_rotate = tmp_b0[:,0]
       #matrix_print_2d(gecp_rotate, 4, 'gecp_rotate')       
       matrix_print_2d(gecp, 4, 'gecp')       
       return gecp_rotate[:,0].reshape(4,1)

    elif (zi == 1 and zj > 1): # first row - second row
       #jcall = 3
       # Only s-s(ecp) will be non-zero
       if nt == 9 or nt == 8:
          # No H-bond parameter if zj is ECP atom
          gssma = resonance_integral(params.beta_s[zi], params.beta_ecp[zj], params.alpha_s[zi], params.alpha_ecp[zj], rij)
          gspma = resonance_integral(params.beta_s[zi], params.beta_ecp[zj], params.alpha_s[zi], params.alpha_ecp[zj], rij)

          gssam = resonance_integral(params.beta_sh[zj], params.beta_ecp[zi], params.alpha_sh[zj], params.alpha_ecp[zi], rij)
          gpsam = resonance_integral(params.beta_ph[zj], params.beta_ecp[zi], params.alpha_ph[zj], params.alpha_ecp[zi], rij)
       else:
          #gssma = resonance_integral(params.beta_s[zi], params.beta_ecp[zj], params.alpha_s[zi], params.alpha_ecp[zj], rij)
          #gpsma = resonance_integral(params.beta_p[zi], params.beta_ecp[zj], params.alpha_p[zi], params.alpha_ecp[zj], rij)

          gssam = resonance_integral(params.beta_s[zj], params.beta_ecp[zi], params.alpha_s[zj], params.alpha_ecp[zi], rij) #Keep
          #gpsam = resonance_integral(params.beta_p[zj], params.beta_ecp[zi], params.alpha_p[zj], params.alpha_ecp[zi], rij)
       #gecp[0][0] = gss
       #gecp[0][1] = gsp
       #gecp[1][0] = -1.0*gps
       print(f'gssma: {gssma}')
       print(f'gssam: {gssam}')
       print(f'gpsma: {-gpsma}')
       print(f'gpsam: {-gpsam}')
       print(f'gspma: {gspma}')
       print(f'gspam: {gspam}')
       gecp_rotate = np.einsum('ji,kj,km->im', rot_mat, gecp, rot_mat) 
       #gecp_rotate = tmp_b0[0,:]
       #matrix_print_2d(gecp_rotate, 1, 'gecp_rotate')       
       matrix_print_2d(gecp, 1, 'gecp')       
       return gecp_rotate[0,:].reshape(1,4)

    elif zi > 1 and zj > 1: 
       #jcall = 4 
       gssma = resonance_integral(params.beta_s[zi], params.beta_ecp[zj], params.alpha_s[zi], params.alpha_ecp[zj], rij) #Keep
       #gspma = resonance_integral(params.beta_s[zi], params.beta_ecp[zj], params.alpha_s[zi], params.alpha_ecp[zj], rij)
       gpsma = resonance_integral(params.beta_p[zi], params.beta_ecp[zj], params.alpha_p[zi], params.alpha_ecp[zj], rij)
       #gppma = resonance_integral(params.beta_p[zi], params.beta_ecp[zj], params.alpha_p[zi], params.alpha_ecp[zj], rij)

       gssam = resonance_integral(params.beta_s[zj], params.beta_ecp[zi], params.alpha_s[zj], params.alpha_ecp[zi], rij) #Keep
       #gspam = resonance_integral(params.beta_s[zj], params.beta_ecp[zi], params.alpha_s[zj], params.alpha_ecp[zi], rij)
       gpsam = resonance_integral(params.beta_p[zj], params.beta_ecp[zi], params.alpha_p[zj], params.alpha_ecp[zi], rij) #Keep
       #gppam = resonance_integral(params.beta_p[zj], params.beta_ecp[zi], params.alpha_p[zj], params.alpha_ecp[zi], rij)

       #gps *= -1.0
       #gpp *= -1.0

       print(f'gssma: {gssma}')
       print(f'gssam: {gssam}')
       print(f'gpsma: {-gpsma}')
       print(f'gpsam: {-gpsam}')
       print(f'gspma: {gspma}')
       print(f'gspam: {gspam}')
       print(f'gppma: {-gppma}')
       print(f'gppam: {-gppam}')

       #gecp[0][0] = gss

       #gecp[0][1] = gsp 
       #gecp[1][0] = gps

       #matrix_print_2d(rot_mat, 4, 'T')       
       #matrix_print_2d(gecp, 4, 'gecp')       
       gecp_rotate = np.einsum('ji,kj,km->im', rot_mat, gecp, rot_mat) 
       #matrix_print_2d(gecp_rotate, 4, 'gecp_rotate')       
       matrix_print_2d(gecp, 4, 'gecp')       
       return gecp_rotate # gecp
    else:
       print('invalid combination of zi and zj')
       exit(-1)

